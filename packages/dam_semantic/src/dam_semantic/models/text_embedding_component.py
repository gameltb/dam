from typing import Any, Dict, Optional, Type

from dam.models.core import BaseComponent
from sqlalchemy import LargeBinary, String
from sqlalchemy.orm import Mapped, mapped_column


class BaseSpecificEmbeddingComponent(BaseComponent):
    """
    Base class for specific embedding components.
    Each subclass will correspond to a unique table for a specific model/hyperparameter combination.
    It does NOT store model_name or model_parameters as columns, as this is implied by the table itself.
    """

    __abstract__ = True  # Makes this a base class not mapped to a table itself

    # The actual embedding vector.
    embedding_vector: Mapped[bytes] = mapped_column(LargeBinary, nullable=False)

    # Information about the source of the text that was embedded.
    source_component_name: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
    source_field_name: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)

    def __repr_base__(self):
        # Helper for subclasses' __repr__
        return (
            f"entity_id={self.entity_id}, "
            f"source='{self.source_component_name}.{self.source_field_name}', "
            f"embedding_vector_len={len(self.embedding_vector) if self.embedding_vector else 0} bytes"
        )


# --- Example Specific Embedding Components ---
# These serve as examples. In a real setup, you'd define these for each
# model/parameter combination you intend to support.
# The table names should be descriptive.


class TextEmbeddingAllMiniLML6V2Dim384Component(BaseSpecificEmbeddingComponent):
    """
    Stores text embeddings generated by 'all-MiniLM-L6-v2' with 384 dimensions.
    """

    __tablename__ = "component_embedding_minilm_l6_v2_d384"
    # Corresponds to model_name="all-MiniLM-L6-v2", params={"dimensions": 384} (implicitly)

    def __repr__(self):
        return f"TextEmbeddingAllMiniLML6V2Dim384Component(id={self.id}, {super().__repr_base__()})"


class TextEmbeddingClipVitB32Dim512Component(BaseSpecificEmbeddingComponent):
    """
    Stores text embeddings generated by a CLIP ViT-B/32 model with 512 dimensions.
    """

    __tablename__ = "component_embedding_clip_vit_b32_d512"
    # Corresponds to model_name="clip-ViT-B-32", params={"dimensions": 512} (implicitly)

    def __repr__(self):
        return f"TextEmbeddingClipVitB32Dim512Component(id={self.id}, {super().__repr_base__()})"


# --- Registry for Embedding Models ---

# Define a type for the hyperparameter dictionary for clarity
ModelHyperparameters = Dict[str, Any]


class EmbeddingModelInfo(Dict[str, Any]):
    model_class: Type[BaseSpecificEmbeddingComponent]
    default_params: ModelHyperparameters


# This registry will map a model_name (string) to its corresponding SQLAlchemy model class
# and potentially default or expected parameters.
# The key for the outer dict is the user-facing model_name.
# The value contains the component class and any default/fixed parameters for that class.
EMBEDDING_MODEL_REGISTRY: Dict[str, EmbeddingModelInfo] = {
    "all-MiniLM-L6-v2": {
        "model_class": TextEmbeddingAllMiniLML6V2Dim384Component,
        "default_params": {"dimensions": 384},  # Example, actual params might vary
    },
    "clip-ViT-B-32": {
        "model_class": TextEmbeddingClipVitB32Dim512Component,
        "default_params": {"dimensions": 512},  # Example
    },
    # Add other models here as they are defined
    # e.g. "multi-qa-MiniLM-L6-cos-v1": {
    #          "model_class": TextEmbeddingMultiQAMiniLML6CosV1Dim384Component,
    #          "default_params": {"dimensions": 384}
    #      }
}


def get_embedding_component_class(
    model_name: str, params: Optional[ModelHyperparameters] = None
) -> Optional[Type[BaseSpecificEmbeddingComponent]]:
    """
    Retrieves the specific embedding component class based on model name and parameters.

    This function will evolve to more strictly match parameters to registered classes
    if multiple classes exist for the same base `model_name` but different key parameters
    that determine the table structure (like dimension).

    For now, it primarily uses `model_name` to find a registered class.
    The `params` argument is noted for future extension where `model_name` alone
    might not be sufficient to pick a table (e.g. if 'all-MiniLM-L6-v2' could
    be used with different output dimensions stored in different tables).
    """
    registry_entry = EMBEDDING_MODEL_REGISTRY.get(model_name)
    if registry_entry:
        # Future enhancement: If params are provided, validate they are compatible
        # with the registered model_class, or use them to select among multiple
        # classes registered for the same base model_name but different critical params.
        # For instance, if we had:
        # "all-MiniLM-L6-v2_384": TextEmbeddingAllMiniLML6V2Dim384Component
        # "all-MiniLM-L6-v2_768": TextEmbeddingAllMiniLML6V2Dim768Component
        # Then params['dimensions'] would be used to pick.
        # For the current setup, we assume model_name is unique enough.
        return registry_entry["model_class"]
    return None


# The old TextEmbeddingComponent should be removed or commented out if no longer used.
# For now, let's comment it out to avoid conflicts and signal it's deprecated.
# Renaming to OldTextEmbeddingComponent and uncommenting for transition period
# until migrations and dependent code are fully updated.


class OldTextEmbeddingComponent(BaseComponent):
    """
    DEPRECATED: Stores text embeddings for an entity, generated from one of its text fields.
    Replaced by specific embedding component tables. This class is kept temporarily for
    module imports and Alembic transition.
    """

    __tablename__ = "component_text_embedding"  # This table will be removed by migrations
    embedding_vector: Mapped[bytes] = mapped_column(LargeBinary, nullable=False)
    model_name: Mapped[str] = mapped_column(String(255), nullable=False)  # Kept for old table structure
    source_component_name: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
    source_field_name: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
    # model_parameters: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSON, nullable=True) # Was from a previous iteration

    def __repr__(self):
        return (
            f"OldTextEmbeddingComponent(id={self.id}, entity_id={self.entity_id}, "
            f"model_name='{self.model_name}', source='{self.source_component_name}.{self.source_field_name}', "
            f"embedding_vector_len={len(self.embedding_vector) if self.embedding_vector else 0} bytes)"
        )


# Ensure __init__.py in dam/models/semantic/ is updated
# to export the new classes and the registry/getter function if needed by other modules.
# For now, the service will directly import from this file.
