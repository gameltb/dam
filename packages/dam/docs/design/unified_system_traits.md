# Design Document: The Unified Trait System

## 1. Introduction and Vision

This document presents a unified and cohesive design for managing system capabilities and execution characteristics within the `dam` framework. It refactors the previously separate concepts of "Asset Traits" and "Resource Scheduling" into a single, powerful abstraction: the **Trait**.

The core vision is that a **Trait** is a universal, context-dependent descriptor. This single concept can be used to describe:
1.  **The capabilities of assets**: What operations can be performed on an entity, based on its components (e.g., it is `AssetContentReadable`).
2.  **The characteristics of systems**: How a system behaves during execution (e.g., its resource usage, its cost, whether it is I/O-bound).

Furthermore, this design introduces a crucial feedback loop: an **Execution Observer** that allows the framework to learn a system's actual performance traits over time and adapt its scheduling decisions for future tasks.

## 2. Core Concept: Traits as Universal Descriptors

A Trait is a data-carrying object that represents a specific characteristic or capability.

### Trait and Implementation Identifiers

The system uses two types of identifiers:

1.  **`TraitIdentifier`**: Uniquely identifies a trait definition (e.g., `asset.operation`). This is a dot-separated string defined on the trait class itself.
2.  **`TraitImplementationIdentifier`**: Uniquely identifies a specific *implementation* of a trait for a given component or set of components. This identifier is automatically generated by the `TraitManager` during registration.

The format of a `TraitImplementationIdentifier` is a separated string: `{trait_identifier}:{component_name}`. For example, `asset.operation:ContentMimeTypeComponent`.

This dual-identifier system allows for:
-   Finding all implementations of a specific trait (e.g., all asset operations).
-   Uniquely referencing a specific implementation with a single string.

You can find a trait with `world.trait_manager.get_trait_by_id("my.trait.identifier")` and a specific implementation with `world.trait_manager.get_implementation_by_id("my.trait.identifier:MyComponent")`.

### 2.1. Component Traits: Describing "What"

A Component Trait describes a capability that an entity possesses due to its components.

*   **Definition**: A trait is defined as a class that acts as a namespace for a set of related commands.
    *   *Example:* The `AssetOperationTrait` defines a standard set of commands (`Add`, `Check`, `Remove`, `ReprocessDerived`) that can be performed on an asset.
*   **Implementation and Binding**: A plugin registers a `TraitImplementation` that maps these abstract commands to concrete system handlers. This implementation is then bound to a specific component class or a **tuple of component classes**.
    *   If a trait is bound to a single component (e.g., `ContentMimeTypeComponent`), any entity with that component has the trait.
    *   If a trait is bound to a tuple of components, the trait only applies to entities that possess **all** components in that tuple.
*   **Discovery**: The `TraitManager` and `world.get_available_traits_for_entity` are the foundation for discovering which traits an entity has at runtime based on these rules.

### 2.2. System Traits: Describing "How"

A System Trait describes how a system behaves when it executes. These traits are the key input for the scheduler.

*   **Definition**: A System Trait is a dataclass representing a specific execution characteristic.
*   **Examples**:
    ```python
    @dataclass
    class ResourceUsageTrait:
        """Declares that a system requires a specific resource."""
        pool_path: str  # e.g., "disk/read/nvme0"
        amount: int = 1

    @dataclass
    class ExecutionCostTrait:
        """The predicted cost of execution."""
        priority: int = 100 # Lower is better
        time_ms: int = 0

    @dataclass
    class IOBoundTrait:
        """A marker trait indicating the system spends most of its time waiting for I/O."""
    ```

### 2.3. Context-Dependent Trait Calculation

A system's traits are not static. Systems must provide a method to calculate their traits dynamically based on the command context.

```python
# In a system file
@system(on_command=GetAssetStreamCommand)
class GetStreamFromZipArchive:
    async def __call__(self, cmd: GetAssetStreamCommand, world: World):
        ...

    @classmethod
    async def calculate_traits(
        cls, cmd: GetAssetStreamCommand, world: World
    ) -> list[Trait]:
        """Dynamically calculate the traits for this execution."""
        # This implementation requires reading from a potentially large zip file.
        traits = [
            ResourceUsageTrait(pool_path="disk/read/hdd0", amount=1),
            ExecutionCostTrait(priority=50, time_ms=100),
            IOBoundTrait(),
        ]
        return traits
```

## 3. Practical Application: Implementing an Asset Operation

To make the concept of Component Traits concrete, this section provides a full, step-by-step example of how the `AssetOperationTrait` is used to implement a "set mime type" operation.

### Step 1: The `AssetOperationTrait` and its Commands

The `AssetOperationTrait` is defined in the core `dam` package. It acts as a namespace for a standard set of commands that can be performed on an asset.

```python
# in dam.traits.asset_operation
@dataclass(frozen=True)
class AssetOperationTrait(Trait):
    """A trait for operations that can be performed on an asset."""
    identifier: TraitIdentifier = TraitIdentifier.from_string("asset.operation")
    description: str = "A collection of commands for asset operations."

    Add = Add
    Check = Check
    Remove = Remove
    ReprocessDerived = ReprocessDerived
```

### Step 2: Implement the Concrete System Logic

Next, a plugin (e.g., the `CorePlugin`) provides the concrete system(s) that handle the logic for a specific component. These systems are standard command handlers.

```python
# in dam.systems.mime_type_system
@system(on_command=AssetOperationTrait.Add)
async def set_mime_type_system(cmd: AssetOperationTrait.Add, world: World) -> None:
    ...

@system(on_command=AssetOperationTrait.Check)
async def check_mime_type_system(cmd: AssetOperationTrait.Check, world: World) -> bool:
    ...

@system(on_command=AssetOperationTrait.Remove)
async def remove_mime_type_system(cmd: AssetOperationTrait.Remove, world: World) -> None:
    ...
```

### Step 3: Register the Trait Implementation

The plugin's `build` method connects the trait, the component, and the system implementation.

```python
# in dam.plugins.core
from dam.core.plugin import Plugin
from dam.core.world import World
from dam.traits.traits import TraitImplementation
from dam.traits.asset_operation import AssetOperationTrait
from dam.models.metadata import ContentMimeTypeComponent
from dam.systems.mime_type_system import (
    set_mime_type_system,
    check_mime_type_system,
    remove_mime_type_system,
)

class CorePlugin(Plugin):
    def build(self, world: World):
        set_mime_type_implementation = TraitImplementation(
            trait=AssetOperationTrait,
            handlers={
                AssetOperationTrait.Add: set_mime_type_system,
                AssetOperationTrait.Check: check_mime_type_system,
                AssetOperationTrait.Remove: remove_mime_type_system,
            },
            name="core.set_mime_type",
            description="Sets the mime type for an asset.",
        )
        world.trait_manager.register(set_mime_type_implementation, ContentMimeTypeComponent)
```

### Step 4: Discover and Use the Trait

Finally, a consumer (e.g., a CLI) can discover and use this trait without needing to know about the underlying components or systems.

```python
# in a CLI command
async def process_entity(entity_id: int, world: World):
    operations = world.trait_manager.get_implementations_for_trait(AssetOperationTrait)
    set_mime_type_op = next((op for op in operations if op.name == "core.set_mime_type"), None)

    if set_mime_type_op:
        # The CLI can now dispatch the abstract command
        await world.dispatch_command(AssetOperationTrait.Add(entity_id=entity_id)).get_all_results()
```

## 4. The Scheduler and Observer: A Learning System

This system creates a feedback loop to enable adaptive performance, using an `ExecutionObserver` to listen to performance metrics from the `SystemExecutor` and storing them in a `SystemPerformanceProfile`.

## 5. The Unified Scheduling Workflow

The scheduling process integrates these concepts:
1.  **Command Dispatch**: Find potential handlers.
2.  **Trait Aggregation**: Gather predicted traits (from `calculate_traits`) and observed traits (from `SystemPerformanceProfile`).
3.  **Intelligent Selection**: A pluggable `AllocationStrategy` uses the traits to make an informed decision.
4.  **Resource-Aware Execution**: The `SystemExecutor` uses `ResourceUsageTrait`s to acquire resource locks.
5.  **Observation and Learning**: The executor publishes an `ExecutionRecord`, updating the profile.

## 6. Advanced Features and Operational Considerations

### 6.1. Scheduler Observability & Debugging

A `debug_dispatch` method will be added to the `WorldScheduler`, which will return a structured `SchedulingReport` object. This report will provide a clear audit trail of the scheduler's decision-making process.

### 6.2. Explicit System Targeting (The Escape Hatch)

The `dispatch_command` method will accept an optional `target_system` parameter to bypass the dynamic selection logic and guarantee predictable execution when required.

### 6.3. Automated Trait Generation via Execution Tracing

This is a forward-looking extension to automate the creation of accurate `System Traits`.
*   **Phase 1: Deep Execution Tracing**: A `SystemTracer` component will use low-level technologies (e.g., eBPF) to capture high-fidelity data.
*   **Phase 2: Diagnostic Reporting**: The trace data is processed into a structured `DiagnosticReport`.
*   **Phase 3: AI-Assisted Trait Generation**: The `DiagnosticReport` is used to prompt an LLM to generate the `calculate_traits` method code, turning a manual task into an AI-assisted review process.

## 7. Conclusion

This unified design provides a powerful and elegant architecture. By abstracting capabilities and characteristics into the single concept of a "Trait," and by incorporating advanced operational tools like observability, escape hatches, and a roadmap for AI-assisted development, this framework is poised to be highly efficient, resilient, and adaptable to future challenges.
